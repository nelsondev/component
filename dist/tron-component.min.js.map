{"version":3,"file":"tron-component.min.js","sources":["../src/core/props.js","../src/core/context.js","../src/core/component.js"],"sourcesContent":["function camelToKebab(str) {\r\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\r\n}\r\n\r\nfunction convertValue(value, type) {\r\n    if (value == null) return value;\r\n\r\n    if (type === Boolean) {\r\n        return value === '' || value === 'true' || value === true;\r\n    }\r\n    if (type === Number) {\r\n        const number = +value;\r\n        return isNaN(number) ? 0 : number;\r\n    }\r\n    if (type === Array || type === Object) {\r\n        if (typeof value === 'string') {\r\n            try {\r\n                return JSON.parse(value);\r\n            } catch {\r\n                return type === Array ? [] : {};\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    return String(value);\r\n}\r\n\r\nexport function createProps(component, propList) {\r\n    const properties = {};\r\n    const proxy = {};\r\n\r\n    component._propsCache = new Map();\r\n\r\n    propList.forEach(prop => {\r\n        const config = typeof prop === 'string'\r\n            ? { name: prop, type: String, default: '' }\r\n            : { type: String, default: '', ...prop };\r\n\r\n        properties[config.name] = config;\r\n    });\r\n\r\n    component.constructor.properties = properties;\r\n    component.constructor.observedAttributes = Object.keys(properties).map(camelToKebab);\r\n\r\n    Object.keys(properties).forEach(name => {\r\n        const config = properties[name];\r\n        const kebabName = camelToKebab(name);\r\n\r\n        Object.defineProperty(proxy, name, {\r\n            get() {\r\n                if (component._propsCache.has(name)) {\r\n                    return component._propsCache.get(name);\r\n                }\r\n\r\n                const attributeValue = component.getAttribute(kebabName);\r\n                const value = attributeValue !== null\r\n                    ? convertValue(attributeValue, config.type)\r\n                    : config.default;\r\n\r\n                if (config.required && value == null) {\r\n                    console.warn(`Required prop '${name}' is missing on ${component.tagName}`);\r\n                }\r\n\r\n                if (config.validator && !config.validator(value)) {\r\n                    console.warn(`Invalid prop '${name}' value:`, value);\r\n                }\r\n\r\n                component._propsCache.set(name, value);\r\n                return value;\r\n            },\r\n\r\n            set(value) {\r\n                if (config.validator && !config.validator(value)) {\r\n                    console.warn(`Invalid prop '${name}' value:`, value);\r\n                    return;\r\n                }\r\n\r\n                const convertedValue = convertValue(value, config.type);\r\n                component.setAttribute(kebabName, convertedValue);\r\n            }\r\n        });\r\n    });\r\n\r\n    component._props = proxy;\r\n    return proxy;\r\n}","import { createProps } from './props.js';\r\n\r\nexport function createContext(component) {\r\n    return {\r\n        /**\r\n         * Reference to the component element\r\n         */\r\n        element: component,\r\n\r\n        /**\r\n         * Define component properties with cleaner API\r\n         */\r\n        defineProps(propList = []) {\r\n            return createProps(component, propList);\r\n        },\r\n\r\n        /**\r\n         * Create event handlers - returns a function that can be used in templates\r\n         */\r\n        defineEvent(handler) {\r\n            const name = `_evt${component._eventCounter++}`;\r\n            const globalName = `${component._instanceId}_${name}`;\r\n\r\n            component[name] = (...args) => handler(...args);\r\n            component._eventHandlers.add({ name, globalName });\r\n\r\n            // Store component reference globally using the unique global name\r\n            window[globalName] = component;\r\n\r\n            const eventWrapper = (...args) => component[name](...args);\r\n\r\n            eventWrapper.toString = () => {\r\n                const handlerString = handler.toString();\r\n                const paramMatch = handlerString.match(/^\\s*(?:async\\s+)?\\(?([^)]*)\\)?\\s*=>/);\r\n                const params = paramMatch ? paramMatch[1].trim() : '';\r\n\r\n                if (!params) {\r\n                    return `window.${globalName}.${name}()`;\r\n                }\r\n                if (params.includes(',')) {\r\n                    return `window.${globalName}.${name}(event)`;\r\n                }\r\n                return `(function(e){e.preventDefault();window.${globalName}.${name}(e)}).call(this,event)`;\r\n            };\r\n\r\n            return eventWrapper;\r\n        },\r\n\r\n        /**\r\n         * Export an event handler to make it available externally on the component\r\n         */\r\n        exportEvent(methodName, handler) {\r\n            const globalName = `${component._instanceId}_${methodName}`;\r\n\r\n            // Create the method on the component\r\n            component[methodName] = (...args) => {\r\n                if (typeof handler === 'function') {\r\n                    return handler(...args);\r\n                } else {\r\n                    // If handler is already a defineEvent result, call it\r\n                    return handler(...args);\r\n                }\r\n            };\r\n\r\n            // Track for cleanup\r\n            component._eventHandlers.add({ name: methodName, globalName });\r\n\r\n            // Store component reference globally\r\n            window[globalName] = component;\r\n\r\n            return component[methodName];\r\n        },\r\n\r\n        /**\r\n         * Define slots with cleaner API\r\n         */\r\n        defineSlots(slotNames = ['default']) {\r\n            const slots = {};\r\n\r\n            slotNames.forEach(slotName => {\r\n                Object.defineProperty(slots, slotName, {\r\n                    get() {\r\n                        // Process slots lazily when first accessed\r\n                        if (!component._slotsProcessed) {\r\n                            component._processSlots();\r\n                        }\r\n\r\n                        if (slotName === 'default') {\r\n                            return component._defaultSlotContent || '';\r\n                        }\r\n                        return component._namedSlots[slotName] || '';\r\n                    }\r\n                });\r\n            });\r\n\r\n            return slots;\r\n        },\r\n\r\n        /**\r\n         * Define component template with cleaner API\r\n         */\r\n        defineTemplate(template) {\r\n            const html = typeof template === 'function' ? template() : String(template);\r\n            component.innerHTML = html;\r\n        },\r\n\r\n        /**\r\n         * Forward classes from the component to its first child or specified selector\r\n         */\r\n        defineStyle() {\r\n            return component.className || '';\r\n        },\r\n\r\n        /**\r\n         * Lifecycle hooks\r\n         */\r\n        onMounted(callback) {\r\n            component.addEventListener('mounted', callback, { once: true });\r\n        },\r\n\r\n        onUnmounted(callback) {\r\n            component.addEventListener('unmounted', callback);\r\n        }\r\n    };\r\n}","import { createContext } from './context.js';\r\n\r\nconst registry = new Map();\r\n\r\nexport function defineComponent(tagName, definition) {\r\n    if (registry.has(tagName)) {\r\n        console.warn(`Component ${tagName} already registered`);\r\n        return registry.get(tagName);\r\n    }\r\n\r\n    class ColeComponent extends HTMLElement {\r\n        static properties = {};\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            // Initialize component state\r\n            this._eventHandlers = new Set();\r\n            this._eventListeners = new Set();\r\n            this._eventCounter = 0;\r\n            this._originalContent = null;\r\n            this._namedSlots = {};\r\n            this._defaultSlotContent = '';\r\n            this._slotsProcessed = false;\r\n\r\n            this._definition = definition;\r\n\r\n            // Create unique instance ID\r\n            this._instanceId = `cc_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n        }\r\n\r\n        connectedCallback() {\r\n            // Capture content immediately when element is connected, before any nested components are upgraded\r\n            this._captureOriginalContent();\r\n            \r\n            // Process the component definition in the next tick to allow content capture\r\n            Promise.resolve().then(() => {\r\n                const context = createContext(this);\r\n                definition.call(context, context);\r\n                this.dispatchEvent(new CustomEvent('mounted'));\r\n            });\r\n        }\r\n\r\n        disconnectedCallback() {\r\n            // Clean up event listeners\r\n            this._eventListeners.forEach(({ element, type, handler }) => {\r\n                element.removeEventListener(type, handler);\r\n            });\r\n            this._eventListeners.clear();\r\n\r\n            // Clean up event handlers\r\n            this._eventHandlers.forEach(({ name, globalName }) => {\r\n                delete this[name];\r\n                delete window[globalName];\r\n            });\r\n            this._eventHandlers.clear();\r\n\r\n            this.dispatchEvent(new CustomEvent('unmounted'));\r\n        }\r\n\r\n        attributeChangedCallback(name, oldValue, newValue) {\r\n            if (oldValue !== newValue && this._propsCache) {\r\n                this._propsCache.delete(this._kebabToCamel(name));\r\n            }\r\n        }\r\n\r\n        render() {\r\n            // Clear all caches\r\n            if (this._propsCache) {\r\n                this._propsCache.clear();\r\n            }\r\n            \r\n            // Reset slot processing to force fresh slot extraction\r\n            this._slotsProcessed = false;\r\n            \r\n            // Re-capture original content (in case slot content changed)\r\n            this._captureOriginalContent();\r\n            \r\n            // Re-run the component definition with fresh context\r\n            const context = createContext(this);\r\n            this._definition.call(context, context);\r\n            \r\n            // Dispatch event for any cleanup/update logic\r\n            this.dispatchEvent(new CustomEvent('rerendered', { \r\n                detail: { timestamp: Date.now() }\r\n            }));\r\n        }\r\n\r\n        _kebabToCamel(str) {\r\n            return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\r\n        }\r\n\r\n        _captureOriginalContent() {\r\n            // Capture the innerHTML immediately - this should contain the original, unprocesed content\r\n            this._originalContent = this.innerHTML;\r\n            \r\n            // Create a map to store content by element reference\r\n            const elementContentMap = new Map();\r\n            \r\n            // Also capture text content of any nested custom elements to preserve their slot content\r\n            const nestedCustomElements = this.querySelectorAll('*');\r\n            nestedCustomElements.forEach(element => {\r\n                const tagName = element.tagName.toLowerCase();\r\n                if (tagName.includes('-') && !element._originalContentCaptured) {\r\n                    // Store the original content mapped to the specific element\r\n                    elementContentMap.set(element, element.innerHTML);\r\n                    element._preservedSlotContent = element.innerHTML;\r\n                    element._originalContentCaptured = true;\r\n                }\r\n            });\r\n            \r\n            // Store the map on this component instance for later use\r\n            this._elementContentMap = elementContentMap;\r\n        }\r\n\r\n        _processSlots() {\r\n            // Only process slots once\r\n            if (this._slotsProcessed) return;\r\n            \r\n            this._extractSlots();\r\n            this._slotsProcessed = true;\r\n        }\r\n\r\n        _extractSlots() {\r\n            if (!this._originalContent) {\r\n                this._namedSlots = {};\r\n                this._defaultSlotContent = '';\r\n                return;\r\n            }\r\n\r\n            // Create a temporary container to safely parse HTML\r\n            const tempDiv = document.createElement('div');\r\n            tempDiv.innerHTML = this._originalContent;\r\n\r\n            // Restore preserved content for any nested custom elements using the stored map\r\n            if (this._elementContentMap) {\r\n                const nestedElements = tempDiv.querySelectorAll('*');\r\n                const realNestedElements = Array.from(this.querySelectorAll('*'));\r\n                \r\n                nestedElements.forEach((element, index) => {\r\n                    const tagName = element.tagName.toLowerCase();\r\n                    if (tagName.includes('-')) {\r\n                        // Match by index within the same tag type to maintain correspondence\r\n                        const realElement = realNestedElements[index];\r\n                        if (realElement && this._elementContentMap.has(realElement)) {\r\n                            element.innerHTML = this._elementContentMap.get(realElement);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Only process slots that are direct children (not nested in other custom elements)\r\n            const namedSlots = {};\r\n            \r\n            // Get direct child template elements with slot attribute\r\n            const directTemplateElements = Array.from(tempDiv.children).filter(child => \r\n                child.tagName === 'TEMPLATE' && child.hasAttribute('slot')\r\n            );\r\n            \r\n            directTemplateElements.forEach(template => {\r\n                const slotName = template.getAttribute('slot');\r\n                namedSlots[slotName] = template.innerHTML;\r\n                template.remove();\r\n            });\r\n\r\n            // Get direct child elements with slot attribute (legacy support)\r\n            const directSlotElements = Array.from(tempDiv.children).filter(child => \r\n                child.hasAttribute('slot') && child.tagName !== 'TEMPLATE'\r\n            );\r\n            \r\n            directSlotElements.forEach(el => {\r\n                const slotName = el.getAttribute('slot');\r\n                if (!namedSlots[slotName]) {\r\n                    namedSlots[slotName] = el.outerHTML;\r\n                }\r\n                el.remove();\r\n            });\r\n\r\n            this._namedSlots = namedSlots;\r\n            \r\n            // Everything remaining is default slot content\r\n            this._defaultSlotContent = tempDiv.innerHTML.trim();\r\n        }\r\n    }\r\n\r\n    customElements.define(tagName, ColeComponent);\r\n    registry.set(tagName, ColeComponent);\r\n    return ColeComponent;\r\n}"],"names":["camelToKebab","str","replace","toLowerCase","convertValue","value","type","Boolean","Number","number","isNaN","Array","Object","JSON","parse","String","createContext","component","element","defineProps","propList","properties","proxy","_propsCache","Map","forEach","prop","config","name","default","constructor","observedAttributes","keys","map","kebabName","defineProperty","get","has","attributeValue","getAttribute","required","console","warn","tagName","validator","set","convertedValue","setAttribute","_props","createProps","defineEvent","handler","_eventCounter","globalName","_instanceId","args","_eventHandlers","add","window","eventWrapper","toString","paramMatch","match","params","trim","includes","exportEvent","methodName","defineSlots","slotNames","slots","slotName","_slotsProcessed","_processSlots","_defaultSlotContent","_namedSlots","defineTemplate","template","html","innerHTML","defineStyle","className","onMounted","callback","addEventListener","once","onUnmounted","registry","definition","ColeComponent","HTMLElement","static","super","this","Set","_eventListeners","_originalContent","_definition","Date","now","Math","random","substring","connectedCallback","_captureOriginalContent","Promise","resolve","then","context","call","dispatchEvent","CustomEvent","disconnectedCallback","removeEventListener","clear","attributeChangedCallback","oldValue","newValue","delete","_kebabToCamel","render","detail","timestamp","_","letter","toUpperCase","elementContentMap","querySelectorAll","_originalContentCaptured","_preservedSlotContent","_elementContentMap","_extractSlots","tempDiv","document","createElement","nestedElements","realNestedElements","from","index","realElement","namedSlots","children","filter","child","hasAttribute","remove","el","outerHTML","customElements","define"],"mappings":"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"}